// See: https://github.com/humanlayer/12-factor-agents/blob/main/content/factor-08-own-your-control-flow.md

import { createStep, createWorkflow } from '@mastra/core/workflows';
import { z } from 'zod';

console.log('üéØ Factor 8: Own Your Control Flow');
console.log('==================================');

// üèóÔ∏è EXPLICIT CONTROL FLOW
// Core concept: Developer owns and controls the execution flow

// üìã EXPLICIT STEP DEFINITIONS
// Each step has clear inputs, outputs, and deterministic logic

const dataValidationStep = createStep({
  id: 'data-validation',
  inputSchema: z.object({
    userInput: z.string(),
    requestId: z.string().optional()
  }),
  outputSchema: z.object({
    isValid: z.boolean(),
    cleanedData: z.string(),
    validationErrors: z.array(z.string()),
    stepInfo: z.object({
      stepName: z.string(),
      timestamp: z.string(),
      processingTime: z.number()
    })
  }),
  async execute({ inputData }) {
    const startTime = Date.now();

    console.log(`\nüîç [Data Validation] Starting step...`);
    console.log(`   Input: "${inputData.userInput}"`);
    console.log(`   Request ID: ${inputData.requestId || 'none'}`);

    // Explicit validation logic - developer controls this
    const errors: string[] = [];
    let cleanedData = inputData.userInput.trim();

    if (cleanedData.length === 0) {
      errors.push('Input cannot be empty');
    }
    if (cleanedData.length > 500) {
      errors.push('Input too long (max 500 characters)');
      cleanedData = cleanedData.slice(0, 500);
    }

    const isValid = errors.length === 0;
    const processingTime = Date.now() - startTime;

    console.log(`   Validation: ${isValid ? 'PASSED' : 'FAILED'}`);
    if (errors.length > 0) {
      console.log(`   Errors: ${errors.join(', ')}`);
    }
    console.log(`   Processing time: ${processingTime}ms`);

    return {
      isValid,
      cleanedData,
      validationErrors: errors,
      stepInfo: {
        stepName: 'data-validation',
        timestamp: new Date().toISOString(),
        processingTime
      }
    };
  },
});

const businessLogicStep = createStep({
  id: 'business-logic',
  inputSchema: z.object({
    isValid: z.boolean(),
    cleanedData: z.string(),
    validationErrors: z.array(z.string()),
    stepInfo: z.object({
      stepName: z.string(),
      timestamp: z.string(),
      processingTime: z.number()
    })
  }),
  outputSchema: z.object({
    processedResult: z.string(),
    businessRules: z.array(z.string()),
    riskLevel: z.enum(['low', 'medium', 'high']),
    needsApproval: z.boolean(),
    stepInfo: z.object({
      stepName: z.string(),
      timestamp: z.string(),
      processingTime: z.number()
    })
  }),
  async execute({ inputData }) {
    const startTime = Date.now();

    console.log(`\n‚öôÔ∏è  [Business Logic] Starting step...`);
    console.log(`   Data valid: ${inputData.isValid}`);
    console.log(`   Previous step: ${inputData.stepInfo.stepName} (${inputData.stepInfo.processingTime}ms)`);

    // Explicit business logic - developer controls this flow
    if (!inputData.isValid) {
      console.log(`   Skipping business logic due to validation errors`);

      return {
        processedResult: 'Processing skipped due to validation errors',
        businessRules: ['validation-required'],
        riskLevel: 'high' as const,
        needsApproval: true,
        stepInfo: {
          stepName: 'business-logic',
          timestamp: new Date().toISOString(),
          processingTime: Date.now() - startTime
        }
      };
    }

    // Apply business rules based on content
    const businessRules: string[] = [];
    let riskLevel: 'low' | 'medium' | 'high' = 'low';
    let needsApproval = false;

    const lowerData = inputData.cleanedData.toLowerCase();

    if (lowerData.includes('delete') || lowerData.includes('remove')) {
      businessRules.push('deletion-protection');
      riskLevel = 'high';
      needsApproval = true;
    } else if (lowerData.includes('update') || lowerData.includes('modify')) {
      businessRules.push('modification-review');
      riskLevel = 'medium';
      needsApproval = false;
    } else {
      businessRules.push('standard-processing');
      riskLevel = 'low';
      needsApproval = false;
    }

    const processedResult = `Processed: ${inputData.cleanedData} (${businessRules.join(', ')})`;
    const processingTime = Date.now() - startTime;

    console.log(`   Applied rules: ${businessRules.join(', ')}`);
    console.log(`   Risk level: ${riskLevel}`);
    console.log(`   Needs approval: ${needsApproval}`);
    console.log(`   Processing time: ${processingTime}ms`);

    return {
      processedResult,
      businessRules,
      riskLevel,
      needsApproval,
      stepInfo: {
        stepName: 'business-logic',
        timestamp: new Date().toISOString(),
        processingTime
      }
    };
  },
});

const outputFormattingStep = createStep({
  id: 'output-formatting',
  inputSchema: z.object({
    processedResult: z.string(),
    businessRules: z.array(z.string()),
    riskLevel: z.enum(['low', 'medium', 'high']),
    needsApproval: z.boolean(),
    stepInfo: z.object({
      stepName: z.string(),
      timestamp: z.string(),
      processingTime: z.number()
    })
  }),
  outputSchema: z.object({
    formattedOutput: z.string(),
    outputFormat: z.string(),
    metadata: z.object({
      processingChain: z.array(z.string()),
      totalProcessingTime: z.number(),
      riskAssessment: z.string()
    }),
    stepInfo: z.object({
      stepName: z.string(),
      timestamp: z.string(),
      processingTime: z.number()
    })
  }),
  async execute({ inputData }) {
    const startTime = Date.now();

    console.log(`\nüìù [Output Formatting] Starting step...`);
    console.log(`   Previous step: ${inputData.stepInfo.stepName} (${inputData.stepInfo.processingTime}ms)`);
    console.log(`   Risk level: ${inputData.riskLevel}`);

    // Explicit output formatting - developer controls this
    const outputFormat = inputData.needsApproval ? 'approval-required' : 'standard';

    const formattedOutput = inputData.needsApproval ? `‚ö†Ô∏è  APPROVAL REQUIRED
Result: ${inputData.processedResult}
Risk Level: ${inputData.riskLevel.toUpperCase()}
Applied Rules: ${inputData.businessRules.join(', ')}
Action: Manual approval needed before proceeding` : `‚úÖ PROCESSING COMPLETE
Result: ${inputData.processedResult}
Risk Level: ${inputData.riskLevel.toUpperCase()}
Applied Rules: ${inputData.businessRules.join(', ')}
Action: Automatically approved`;

    const processingTime = Date.now() - startTime;
    const totalProcessingTime = inputData.stepInfo.processingTime + processingTime;

    console.log(`   Output format: ${outputFormat}`);
    console.log(`   Processing time: ${processingTime}ms`);
    console.log(`   Total pipeline time: ${totalProcessingTime}ms`);

    return {
      formattedOutput,
      outputFormat,
      metadata: {
        processingChain: ['data-validation', 'business-logic', 'output-formatting'],
        totalProcessingTime,
        riskAssessment: `${inputData.riskLevel} risk with ${inputData.businessRules.length} rules applied`
      },
      stepInfo: {
        stepName: 'output-formatting',
        timestamp: new Date().toISOString(),
        processingTime
      }
    };
  },
});

// üîó EXPLICIT WORKFLOW COMPOSITION
// Developer explicitly defines the execution flow

const standardWorkflow = createWorkflow({
  id: 'standard-control-flow',
  inputSchema: z.object({
    userInput: z.string(),
    requestId: z.string().optional()
  }),
  outputSchema: z.object({
    formattedOutput: z.string(),
    outputFormat: z.string(),
    metadata: z.object({
      processingChain: z.array(z.string()),
      totalProcessingTime: z.number(),
      riskAssessment: z.string()
    }),
    stepInfo: z.object({
      stepName: z.string(),
      timestamp: z.string(),
      processingTime: z.number()
    })
  }),
  steps: [dataValidationStep, businessLogicStep, outputFormattingStep]
})
  .then(dataValidationStep)    // Step 1: Developer controls this executes first
  .then(businessLogicStep)     // Step 2: Developer controls this executes second
  .then(outputFormattingStep)  // Step 3: Developer controls this executes third
  .commit();

// üé≠ CONTROL FLOW DEMONSTRATIONS
// Automated scenarios showing different control flow patterns

interface ControlFlowScenario {
  name: string;
  description: string;
  input: string;
  expectedFlow: string[];
  expectedRisk: 'low' | 'medium' | 'high';
}

const scenarios: ControlFlowScenario[] = [
  {
    name: 'Standard Processing',
    description: 'Normal flow with low-risk input',
    input: 'Create a new user account for John',
    expectedFlow: ['data-validation', 'business-logic', 'output-formatting'],
    expectedRisk: 'low'
  },
  {
    name: 'Validation Error',
    description: 'Flow handles invalid input explicitly',
    input: '', // Empty input will trigger validation error
    expectedFlow: ['data-validation', 'business-logic', 'output-formatting'],
    expectedRisk: 'high'
  },
  {
    name: 'Medium Risk Processing',
    description: 'Modification request with medium risk',
    input: 'Update user profile settings for existing account',
    expectedFlow: ['data-validation', 'business-logic', 'output-formatting'],
    expectedRisk: 'medium'
  },
  {
    name: 'High Risk Processing',
    description: 'Deletion request requiring approval',
    input: 'Delete all user accounts permanently',
    expectedFlow: ['data-validation', 'business-logic', 'output-formatting'],
    expectedRisk: 'high'
  }
];

// üéØ CONTROLLED EXECUTION DEMONSTRATION
async function demonstrateControlFlow() {
  console.log(`\n${'='.repeat(60)}`);
  console.log('üéØ Explicit Control Flow Demonstrations');
  console.log(`${'='.repeat(60)}`);

  for (const [index, scenario] of scenarios.entries()) {
    console.log(`\n${'‚îÄ'.repeat(50)}`);
    console.log(`üìç Scenario ${index + 1}: ${scenario.name}`);
    console.log(`üìù ${scenario.description}`);
    console.log(`üéØ Expected Flow: ${scenario.expectedFlow.join(' ‚Üí ')}`);
    console.log(`‚ö†Ô∏è  Expected Risk: ${scenario.expectedRisk}`);
    console.log(`${'‚îÄ'.repeat(50)}`);

    console.log(`\nüöÄ Executing workflow with input: "${scenario.input}"`);

    try {
      const run = standardWorkflow.createRun();
      const result = await run.start({
        inputData: {
          userInput: scenario.input,
          requestId: `demo-${index + 1}`
        }
      });

      if (result.status === 'success') {
        const finalStep = result.steps['output-formatting'];
        if (finalStep.status === 'success') {
          console.log(`\n‚úÖ Workflow completed successfully!`);
          console.log(`\nüìã Final Output:`);
          console.log(finalStep.output.formattedOutput);

          console.log(`\nüìä Execution Metadata:`);
          console.log(`   Processing Chain: ${finalStep.output.metadata.processingChain.join(' ‚Üí ')}`);
          console.log(`   Total Processing Time: ${finalStep.output.metadata.totalProcessingTime}ms`);
          console.log(`   Risk Assessment: ${finalStep.output.metadata.riskAssessment}`);

          // Verify expected flow
          const actualFlow = finalStep.output.metadata.processingChain;
          const flowMatches = JSON.stringify(actualFlow) === JSON.stringify(scenario.expectedFlow);
          console.log(`\nüéØ Flow Verification: ${flowMatches ? '‚úÖ MATCHES' : '‚ùå DIFFERS'}`);

        } else {
          console.log(`‚ùå Final step failed: ${finalStep.status}`);
        }
      } else {
        console.log(`‚ùå Workflow failed: ${result.status}`);
      }

    } catch (error) {
      console.log(`‚ùå Execution error: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
}

// üí° CONTROL FLOW BENEFITS DEMONSTRATION
async function demonstrateBenefits() {
  console.log(`\n${'='.repeat(60)}`);
  console.log('üí° Factor 8 Benefits: Owned Control Flow');
  console.log(`${'='.repeat(60)}`);

  console.log('\n‚úÖ Explicit Step Definition:');
  console.log('   üîß Each step has clear inputs and outputs');
  console.log('   üìã Deterministic logic controlled by developer');
  console.log('   üîç Full visibility into step implementation');

  console.log('\n‚úÖ Controlled Flow Composition:');
  console.log('   üîó Developer explicitly defines step order');
  console.log('   ‚ö° No hidden framework routing logic');
  console.log('   üéØ Predictable execution sequence');

  console.log('\n‚úÖ Transparent Execution:');
  console.log('   üìù Each step logs its progress explicitly');
  console.log('   ‚è±Ô∏è  Processing times tracked at each step');
  console.log('   üîç Full audit trail of execution path');

  console.log('\n‚úÖ Deterministic Behavior:');
  console.log('   üéØ Same inputs always produce same flow');
  console.log('   üêõ Easy to debug and test individual steps');
  console.log('   üîÑ Reliable and repeatable execution');

  console.log('\nüèóÔ∏è Control Flow Patterns:');
  console.log('   üìä Sequential processing (A ‚Üí B ‚Üí C)');
  console.log('   üîÄ Conditional branching (if/else logic)');
  console.log('   ‚ö†Ô∏è  Error handling (try/catch patterns)');
  console.log('   üîÑ Loop control (iteration patterns)');

  console.log('\nüö´ Anti-Patterns Avoided:');
  console.log('   ‚ùå Framework-hidden control flow');
  console.log('   ‚ùå LLM-driven routing decisions');
  console.log('   ‚ùå Implicit step dependencies');
  console.log('   ‚ùå Black box execution paths');
}

// üîç FLOW TRANSPARENCY DEMONSTRATION
async function demonstrateTransparency() {
  console.log(`\n${'='.repeat(60)}`);
  console.log('üîç Flow Transparency and Debugging');
  console.log(`${'='.repeat(60)}`);

  console.log('\nüìä Workflow Architecture:');
  console.log('   Step 1: data-validation (input validation and cleaning)');
  console.log('   Step 2: business-logic (rule application and risk assessment)');
  console.log('   Step 3: output-formatting (final output generation)');

  console.log('\nüîó Data Flow Between Steps:');
  console.log('   userInput ‚Üí cleanedData ‚Üí processedResult ‚Üí formattedOutput');
  console.log('   stepInfo propagated through entire chain for full traceability');

  console.log('\nüéØ Developer Control Points:');
  console.log('   ‚úÖ Validation rules (what constitutes valid input)');
  console.log('   ‚úÖ Business logic (how to process different input types)');
  console.log('   ‚úÖ Risk assessment (what requires approval)');
  console.log('   ‚úÖ Output formatting (how results are presented)');
  console.log('   ‚úÖ Error handling (how failures are managed)');

  console.log('\nüêõ Debugging Capabilities:');
  console.log('   üîç Each step can be tested independently');
  console.log('   üìù Complete execution logs at each step');
  console.log('   ‚è±Ô∏è  Performance metrics for each step');
  console.log('   üéØ Clear error messages and failure points');
  console.log('   üìä Metadata tracking for complete audit trail');
}

async function main() {
  console.log('\n‚ú® Factor 8 demonstrates explicit developer-controlled execution flow');
  console.log('   - Each step is explicitly defined with clear inputs and outputs');
  console.log('   - Developer controls the exact sequence of operations');
  console.log('   - Transparent logging shows progress at each step');
  console.log('   - Deterministic execution with no hidden framework logic');
  console.log('   - Easy to debug, test, and modify control flow\n');

  await demonstrateControlFlow();
  await demonstrateBenefits();
  await demonstrateTransparency();

  console.log(`\n${'='.repeat(60)}`);
  console.log('üéâ Factor 8 Demo Complete!');
  console.log(`${'='.repeat(60)}`);
  console.log('\nüí° Key Takeaways:');
  console.log('   ‚úÖ Explicit step definitions with clear inputs/outputs');
  console.log('   ‚úÖ Developer-controlled flow composition');
  console.log('   ‚úÖ Transparent execution with full logging');
  console.log('   ‚úÖ Deterministic behavior and predictable flows');
  console.log('   ‚úÖ Easy debugging and testing capabilities');
  console.log('   ‚úÖ No hidden framework or LLM-driven routing');
}

main().catch(console.error);
